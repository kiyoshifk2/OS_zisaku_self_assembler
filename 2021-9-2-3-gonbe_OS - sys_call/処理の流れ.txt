１．　タイマー割り込み処理（割り込みはこれのみ）
　　　タイマーは 10msec 毎に割り込みを発生する

１．１．　タイマー割り込みの初期化
　　　・IDT テーブル設定、init_gdtidt();
　　　・割り込みコントローラの設定、init_pic();
　　　・enable_interrupt();
　　　・timer のハードウエア設定して 10ms 周期の割り込みに設定する
　　　・タイマー割り込みの許可（この処理は初期化の一番後ろにしている）

１．２．　10msec 割り込み処理

１．２．１．　tick のカウント
　　　10msec 毎にカウントアップする GetTickCount() にて 1msec 単位に換算した経過時間を獲得できる

１．２．２．　キー入力
　　　10msec 割り込みごとに BIOS の int 16h にて１回キー入力する
　　　BIOS コールする為に 16bit のリアルモードに一旦戻してから int 16h を実行している

１．２．３．　タイマー処理
　　　タイマーには repeat timer と oneshot タイマーが有るが oneshot timer のみ使用する

１．２．３．１．　oneshot タイマー処理
      set_oneshot_timer() にて oneshot timer を１個設定する
　　　設定内容は fire するまでの時間（msec）と fire した時にメッセージを送る fifo のアドレスが必要
　　　タイマーが fire すると fifo にメッセージを送りタイマーは消滅する
　　　メッセージを送れない場合はタイマーは残り次に割り込みでリトライする

１．２．４．　タスクのディスパッチ
　　　10msec 割り込み毎に task_switch() を呼び出してタスクのディスパッチを行う、但し
　　　初期化が完了する前のディスパッチを防ぐために割り込みが 10回入るまでは task_switch() を呼び出さない

２．　タスクのディスパッチ処理
２．１．　概要
　　　タスクごとに GDT テーブルに task status register(tss) を登録しておく
      初めに１回メインタスクの tss の selector(GDT テーブル番号)を　CPU の tr レジスタにセットしておく
　　　そうすると初回のタスク切替 farjmp() にてこの tss に CPU 情報が書き込まれてから farjmp するから
　　　この tss の初期値は簡略な物で良い
　　　タスク切替 farjmp() とは tss をセットした GDT テーブルエントリーへの farjmp である
　　　この tss の初期値は CPU 情報の初期値を正しく設定しておく必要がある
　　　その後はタスク切替 farjmp() にて tss 情報がアップデートされていく

２．２．　初期化
２．２．１．　メインタスクの初期化
　　　・メインタスク用の窓と fifo を初期化する
　　　・task_init(); にてシステムで１回だけ　struct TASKCTL *taskctl; エリアを獲得/初期化し
　　　　メインタスク用の管理領域も獲得/初期化する
　　　・メインタスク用の fifo にメインタスクを関係づけるこれによりメインタスクが sleep していても
　　　　メインタスクにメッセージを送るとタスクを wakeup する事が出来る
　　　・task_run() を実行するこの中で task_add() を呼び出してメインタスクを taskctl に実行可能タスクとして登録する
　　　・メインタスクを初回実行拒否タスクとして登録する、こうしないと初回の farjmp() にて
　　　　不完全な tss に飛び込んで暴走する
　　　・タイマー割り込みを有効にするのは（ディスパッチ開始）メインタスクとサブタスクを全て設定した後である

２．２．２．　サブタスクの初期化
２．２．２．１．　メインタスクにて行う初期化
　　　・サブタスク用の窓の初期化
　　　・タスク情報エリアを獲得し詳細な設定を行う（eip/esp/セグメントレジスタ/スタックに乗せるパラメータ）
      ・task_run() にて taskctl エリアに実行可能タスクとして登録する
２．２．２．２．　サブタスクにて行う初期化
　　　・サブタスク用の fifo はサブタスクの先頭で初期化する

２．３．　ディスパッチ処理　task_switch() にて行う
　　　この関数はタイマー割り込み内で呼び出されるから、この関数は main プログラムのどこでも割り込んでくるから
　　　この後説明する変数の設定タイミングは重要である

２．３．１．　初回 farjmp() 処理
　　　初回の farjmp() ではメインタスクに飛び込む訳にはいかない（tss が不完全な為）
　　　この為初回だけは初回実行拒否タスク以外のタスクに飛び込まなければならない

２．３．２．　初回以後のディスパッチ処理
　　　実行可能タスクが無い時は他のプログラムで inhibit_task_switch をセットしておき、ここの先頭で return する
　　　他のプログラムで inhibit_task_swith をセットリセットしているタイミングはクリティカルであるから注意する事
　　　farjmp() するのは現在実行中のタスクと新しく実行すべきタスクが異なっている場合である、この処理は下記の通り

２．３．２．１　現在実行中のタスクと新しく実行すべきタスクのチェック方法
２．３．２．１．１．　現在実行中のタスクの獲得
　　　・taskctl->now_lv から現在実行中の level を獲得して  tl にセットする
　　　・tl->now からタスク番号を得て現在実行中タスクを獲得する

２．３．２．１．２．　新しく実行すべきタスクの獲得
　　　・現在実行中の tl->now を次に進めておく（１つしかない場合は変化なし）
　　　・別のプログラムでレベル変更が必要かどうかの判定を行い必要ならば lv_change をセットしておく
　　　・lv_change がセットされていたら tl を実行可能最優先レベルにする
　　　・新しく実行すべきタスクは tl->now である

２．３．２．１．３．　farjmp() 処理の実行
　　　現在タスクと実行すべきタスクが異なる場合は farjmp() を呼び出してディスパッチする
　　　inhibit_task_swith がリセットされている場合は taskctl->now_lv や tl->now が正しくセットされていなければならない
　　　これらが正しくセットされるタイミングとinhibit_task_swith がリセットされるタイミングには十分に注意する必要が有る
　　　これらは他の関数でセットされるためそれらの関数呼び出しを新しく行う場合は十分な注意が必要

２．４．　task_sleep() 処理
　　　実行可能タスクが無い状態で呼び出すと内部で hlt するから割り込みルーチンからは呼び出せない
　　　この関数では基本的には実行中の自タスクを taskctl テーブルから削除するその後で
　　　実行可能タスクへ farjmp() してディスパッチする、実行可能タスクが無い場合は内部で hlt する
　　　hlt するとタイマー割り込みルーチンで実行可能タスクが登録されるまでは再度 hlt し続ける
　　　実行可能タスクが登録されるのは現在の所はタイマーが fire して fifo に fifo32_put() を実行すときだけである
      fifo32_put() の中で task_run() しているがこの関数は inhibit_task_switch を壊すから復元した
　　　実行可能タスクが登録されたら task_switch() でそのタスクがディスパッチされる、そのタスクは hlt している現在タスクである
　　　そうすると　自分自身に farjmp() して暴走する　これを逃げるために task_swith() ないで
　　　現在タスクと新規実行タスクが同じになるから問題ない、各種変数が正しくセットされていればこうなるのだ







fifo にメッセージを送ると 関係づけられたタスクを起こす
